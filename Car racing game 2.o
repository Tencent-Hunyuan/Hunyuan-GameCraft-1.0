import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.AffineTransform;
import java.util.*;

public class OffRoadParkingGame {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Off-Road Parking / Racing Prototype");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            GamePanel panel = new GamePanel(1024, 700);
            frame.setContentPane(panel);
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
            panel.start();
        });
    }
}

class GamePanel extends JPanel implements ActionListener, KeyListener {
    private final int width, height;
    private final Timer timer;
    private final PlayerCar player;
    private final java.util.List<AICar> aiCars = new ArrayList<>();
    private final java.util.List<Wall> walls = new ArrayList<>();
    private final java.util.List<ParkingZone> parkingZones = new ArrayList<>();
    private final TerrainMap terrain;
    private boolean up, down, left, right;
    private long startTime;
    private boolean parked = false;

    public GamePanel(int w, int h) {
        this.width = w; this.height = h;
        setPreferredSize(new Dimension(w, h));
        setFocusable(true);
        addKeyListener(this);
        timer = new Timer(16, this); // ~60 FPS

        // Create simple terrain
        terrain = new TerrainMap(w, h);
        terrain.generate();

        player = new PlayerCar(w/2.0, h-120.0, 0);

        // Add AI cars
        AICar ai1 = new AICar(200, 200, Math.toRadians(90));
        ai1.addWaypoint(200, 500);
        ai1.addWaypoint(800, 500);
        ai1.addWaypoint(800, 150);
        ai1.setMaxSpeed(3.2);
        aiCars.add(ai1);

        AICar ai2 = new AICar(600, 100, Math.toRadians(0));
        ai2.addWaypoint(600, 400);
        ai2.addWaypoint(300, 400);
        ai2.setMaxSpeed(2.6);
        aiCars.add(ai2);

        // Walls (simple obstacles)
        walls.add(new Wall(50, 50, 900, 20)); // top horizontal
        walls.add(new Wall(50, 580, 900, 20));
        walls.add(new Wall(50, 50, 20, 550));
        walls.add(new Wall(930, 50, 20, 550));

        // Parking zones (x, y, w, h)
        parkingZones.add(new ParkingZone(820, 520, 120, 80, Color.GREEN.darker()));

        startTime = System.currentTimeMillis();
    }

    public void start() { timer.start(); }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g.create();
        // smooth
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        // Draw terrain
        terrain.paint(g2);

        // Draw parking zones
        for (ParkingZone p : parkingZones) p.paint(g2);

        // Draw walls
        g2.setColor(Color.DARK_GRAY);
        for (Wall w : walls) w.paint(g2);

        // Draw AI cars
        for (AICar ai : aiCars) ai.paint(g2);

        // Draw player car
        player.paint(g2);

        // Draw HUD
        drawHUD(g2);

        g2.dispose();
    }

    private void drawHUD(Graphics2D g2) {
        g2.setColor(Color.WHITE);
        g2.setFont(new Font("SansSerif", Font.BOLD, 14));
        String speed = String.format("Speed: %.1f", player.getSpeed()*10);
        String gear = "Gear: " + player.getGear();
        long elapsed = (System.currentTimeMillis() - startTime) / 1000;
        g2.drawString(speed + " | " + gear + " | Time: " + elapsed + "s", 12, 20);

        g2.setFont(new Font("SansSerif", Font.PLAIN, 12));
        g2.drawString("Controls: W/A/S/D or Arrow keys. Press P to park/finish.", 12, 40);

        if (parked) {
            g2.setColor(new Color(0, 0, 0, 150));
            g2.fillRect(width/2-160, height/2-60, 320, 120);
            g2.setColor(Color.GREEN);
            g2.setFont(new Font("SansSerif", Font.BOLD, 22));
            g2.drawString("PARKED! Level Complete", width/2-140, height/2);
            g2.setFont(new Font("SansSerif", Font.PLAIN, 14));
            g2.drawString("Press R to restart", width/2-60, height/2+30);
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (!parked) {
            // Player input -> apply to player
            double accelInput = 0;
            if (up) accelInput += 1;
            if (down) accelInput -= 1;
            player.applyControls(accelInput, left ? -1 : 0, right ? 1 : 0);

            // Update player terrain effects
            if (terrain.isOffRoad(player.getCenterX(), player.getCenterY())) player.setOffRoad(true);
            else player.setOffRoad(false);

            player.update();

            // Update AI cars
            for (AICar ai : aiCars) {
                ai.update();
                // simple avoidance: if too close to player, slow down
                double dx = ai.x - player.x;
                double dy = ai.y - player.y;
                double dist = Math.hypot(dx, dy);
                if (dist < 60) ai.applyBrake(0.6);
            }

            // Collisions
            handleCollisions();

            // Check parking
            for (ParkingZone p : parkingZones) {
                if (p.contains(player)) {
                    parked = true;
                    player.setSpeed(0);
                }
            }
        }

        repaint();
    }

    private void handleCollisions() {
        // player vs walls
        Rectangle pr = player.getBounds();
        for (Wall w : walls) {
            if (pr.intersects(w.getRect())) {
                // simple bounce
                player.setSpeed(player.getSpeed()* -0.4);
                player.moveBack();
            }
        }
        // player vs AI
        for (AICar ai : aiCars) {
            if (pr.intersects(ai.getBounds())) {
                // basic elastic-ish response
                double nx = player.x - ai.x;
                double ny = player.y - ai.y;
                double d = Math.max(1e-3, Math.hypot(nx, ny));
                nx /= d; ny /= d;
                player.x += nx * 6;
                player.y += ny * 6;
                player.setSpeed(player.getSpeed()*0.6);
                ai.setSpeed(ai.getSpeed()*0.6);
            }
        }
    }

    // KeyListener
    @Override
    public void keyTyped(KeyEvent e) {}
    @Override
    public void keyPressed(KeyEvent e) {
        int k = e.getKeyCode();
        if (k == KeyEvent.VK_W || k == KeyEvent.VK_UP) up = true;
        if (k == KeyEvent.VK_S || k == KeyEvent.VK_DOWN) down = true;
        if (k == KeyEvent.VK_A || k == KeyEvent.VK_LEFT) left = true;
        if (k == KeyEvent.VK_D || k == KeyEvent.VK_RIGHT) right = true;
        if (k == KeyEvent.VK_P) { // force park
            for (ParkingZone p : parkingZones) if (p.contains(player)) parked = true;
        }
        if (k == KeyEvent.VK_R) { // restart
            restart();
        }
    }
    @Override
    public void keyReleased(KeyEvent e) {
        int k = e.getKeyCode();
        if (k == KeyEvent.VK_W || k == KeyEvent.VK_UP) up = false;
        if (k == KeyEvent.VK_S || k == KeyEvent.VK_DOWN) down = false;
        if (k == KeyEvent.VK_A || k == KeyEvent.VK_LEFT) left = false;
        if (k == KeyEvent.VK_D || k == KeyEvent.VK_RIGHT) right = false;
    }

    private void restart() {
        player.reset(width/2.0, height-120.0, 0);
        for (AICar ai : aiCars) ai.reset();
        parked = false;
        startTime = System.currentTimeMillis();
    }
}

abstract class CarBase {
    double x, y; // center
    double angle; // radians
    double speed = 0;
    double maxSpeed = 4.5;
    double accel = 0.12;
    double turnSpeed = Math.toRadians(3.8);
    final int w = 36, h = 18; // car size
    boolean offRoad = false;

    public CarBase(double x, double y, double angle) { this.x = x; this.y = y; this.angle = angle; }

    public void setOffRoad(boolean v) { offRoad = v; }
    public double getCenterX() { return x; }
    public double getCenterY() { return y; }

    public Rectangle getBounds() {
        return new Rectangle((int)(x - w/2), (int)(y - h/2), w, h);
    }

    public void paintCarShape(Graphics2D g2, Color base) {
        AffineTransform old = g2.getTransform();
        g2.translate(x, y);
        g2.rotate(angle);
        g2.setColor(base);
        g2.fillRoundRect(-w/2, -h/2, w, h, 6, 6);
        // windshield
        g2.setColor(Color.LIGHT_GRAY);
        g2.fillRect(-6, -h/2, 12, h/2);
        g2.setTransform(old);
    }

    public double getSpeed() { return speed; }
    public void setSpeed(double s) { speed = s; }
    public void setMaxSpeed(double m) { maxSpeed = m; }
}

class PlayerCar extends CarBase {
    private int gear = 1;
    private double lastX, lastY;

    public PlayerCar(double x, double y, double angle) { super(x,y,angle); }

    public void applyControls(double accelInput, int leftInput, int rightInput) {
        lastX = x; lastY = y;
        double effectiveAccel = accel * (offRoad ? 0.45 : 1.0);
        // accelerate / brake
        speed += accelInput * effectiveAccel;
        // natural friction
        speed *= 0.995;
        speed = Math.max(-2.0, Math.min(maxSpeed, speed));

        // turning is more effective at low speeds
        double turnAmt = turnSpeed * (1.0 - Math.min(1.0, Math.abs(speed)/maxSpeed));
        if (leftInput != 0) angle -= turnAmt * 1.8;
        if (rightInput != 0) angle += turnAmt * 1.8;

        // simple gear
        if (speed > 0.8) gear = 3;
        else if (speed > 0.3) gear = 2;
        else gear = 1;
    }

    public void update() {
        // move
        x += Math.cos(angle) * speed * 2.0;
        y += Math.sin(angle) * speed * 2.0;

        // small clamp to screen
        x = Math.max(20, Math.min(1004, x));
        y = Math.max(20, Math.min(680, y));

        // if off-road reduce speed gradually
        if (offRoad) speed *= 0.995;
    }

    public int getGear() { return gear; }

    public void moveBack() {
        x = lastX; y = lastY;
    }

    public void reset(double nx, double ny, double a) {
        x = nx; y = ny; angle = a; speed = 0; gear = 1;
    }

    @Override
    public void paintCarShape(Graphics2D g2, Color base) {
        // draw shadow
        g2.setColor(new Color(0,0,0,40));
        g2.fillOval((int)(x-18), (int)(y-10), 36, 14);
        super.paintCarShape(g2, base);
        // draw wheels
        AffineTransform old = g2.getTransform();
        g2.translate(x, y);
        g2.rotate(angle);
        g2.setColor(Color.BLACK);
        g2.fillRect(-16, -11, 6, 4);
        g2.fillRect(10, -11, 6, 4);
        g2.fillRect(-16, 7, 6, 4);
        g2.fillRect(10, 7, 6, 4);
        g2.setTransform(old);
    }
}

class AICar extends CarBase {
    private final List<Point> waypoints = new ArrayList<>();
    private int current = 0;
    private final double baseMaxSpeed;
    private double startX, startY, startAngle;

    public AICar(double x, double y, double angle) { super(x,y,angle); baseMaxSpeed = maxSpeed; startX = x; startY = y; startAngle = angle; }

    public void addWaypoint(int x, int y) { waypoints.add(new Point(x,y)); }
    public void setMaxSpeed(double s) { maxSpeed = s; }

    public void update() {
        if (waypoints.isEmpty()) return;
        Point target = waypoints.get(current);
        double dx = target.x - x;
        double dy = target.y - y;
        double angToTarget = Math.atan2(dy, dx);
        double diff = normalizeAngle(angToTarget - angle);
        // turn towards waypoint
        if (diff > 0.05) angle += 0.03;
        else if (diff < -0.05) angle -= 0.03;

        // accelerate towards waypoint
        double dist = Math.hypot(dx, dy);
        double targetSpeed = Math.min(maxSpeed, dist/60.0 + 0.4);
        if (speed < targetSpeed) speed += 0.02;
        else speed -= 0.01;
        speed = Math.max(0, Math.min(maxSpeed, speed));

        x += Math.cos(angle) * speed * 2.0;
        y += Math.sin(angle) * speed * 2.0;

        if (dist < 30) {
            current = (current + 1) % waypoints.size();
        }
    }

    public void applyBrake(double amt) { speed = Math.max(0, speed - amt); }

    private double normalizeAngle(double a) {
        while (a <= -Math.PI) a += Math.PI*2;
        while (a > Math.PI) a -= Math.PI*2;
        return a;
    }

    public void setSpeed(double s) { speed = s; }
    public void reset() { x = startX; y = startY; angle = startAngle; speed = 0; }

    public void paint(Graphics2D g2) {
        paintCarShape(g2, Color.RED);
        // optional: draw next waypoint line
        if (!waypoints.isEmpty()) {
            Point p = waypoints.get(current);
            g2.setColor(new Color(255,255,255,80));
            g2.drawLine((int)x, (int)y, p.x, p.y);
        }
    }
}

class Wall {
    int x,y,w,h;
    public Wall(int x,int y,int w,int h){this.x=x;this.y=y;this.w=w;this.h=h;}
    public Rectangle getRect(){return new Rectangle(x,y,w,h);}
    public void paint(Graphics2D g){g.fillRect(x,y,w,h);}
}

class ParkingZone {
    int x,y,w,h; Color c;
    public ParkingZone(int x,int y,int w,int h, Color c){this.x=x;this.y=y;this.w=w;this.h=h;this.c=c;}
    public void paint(Graphics2D g){
        g.setColor(c);
        g.fillRoundRect(x,y,w,h,8,8);
        g.setColor(new Color(255,255,255,160));
        g.drawRoundRect(x,y,w,h,8,8);
    }
    public boolean contains(PlayerCar p) {
        Rectangle r = p.getBounds();
        return r.intersects(new Rectangle(x,y,w,h));
    }
}

// Very simple top-down terrain map: road (dark), off-road grass (green)
class TerrainMap {
    int w,h;
    java.util.List<Rectangle> roads = new ArrayList<>();
    public TerrainMap(int w,int h){this.w=w;this.h=h;}
    public void generate(){
        // central winding road strip(s)
        roads.add(new Rectangle(50, 220, 900, 120));
        roads.add(new Rectangle(250, 50, 120, 640));
        roads.add(new Rectangle(480, 120, 300, 120));
    }
    public void paint(Graphics2D g){
        // background grass
        g.setColor(new Color(50,150,50));
        g.fillRect(0,0,w,h);
        // offroad dirt patches
        g.setColor(new Color(160,120,60));
        g.fillOval(80,420,240,140);

        // draw roads
        g.setColor(new Color(40,40,40));
        for (Rectangle r: roads) g.fillRoundRect(r.x, r.y, r.width, r.height, 20, 20);

        // road markings
        g.setColor(new Color(255,255,0,120));
        for (int i=0;i<w;i+=40) g.fillRect(i, 280, 20, 4);

        // sand / parking lot area
        g.setColor(new Color(200,200,190));
        g.fillRect(760, 460, 240, 160);
    }
    public boolean isOffRoad(double x, double y){
        // if inside any road rect -> on road
        for (Rectangle r: roads) if (r.contains((int)x,(int)y)) return false;
        // parking lot area is not off-road
        if (new Rectangle(760,460,240,160).contains((int)x,(int)y)) return false;
        // else off road (grass/dirt)
        return true;
    }
}


Done — I created a runnable Java prototype for an off-road parking / racing game and put the full source in a canvas titled "Off Road Parking Game" (file: OffRoadParkingGame.java).

What I included:

Single-file Swing game you can compile & run (javac OffRoadParkingGame.java → java OffRoadParkingGame).

Player controls (W/A/S/D or arrows), simple physics, AI cars, collisions, off-road terrain effects, parking zone & win state, and a small HUD.

Comments and next-step ideas (swap in luxury car sprites, improve physics, add menus, port to mobile with libGDX, etc.).


Open the canvas on the right to view, copy, or edit the full Java code. If you want, I can now.
